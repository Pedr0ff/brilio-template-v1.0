{"ast":null,"code":"// package.json\nvar version = \"1.1.21\";\n\n// packages/core/src/maths.ts\nfunction clamp(min, input, max) {\n  return Math.max(min, Math.min(input, max));\n}\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n}\nfunction damp(x, y, lambda, deltaTime) {\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime));\n}\nfunction modulo(n, d) {\n  return (n % d + d) % d;\n}\n\n// packages/core/src/animate.ts\nvar Animate = class {\n  isRunning = false;\n  value = 0;\n  from = 0;\n  to = 0;\n  currentTime = 0;\n  // These are instanciated in the fromTo method\n  lerp;\n  duration;\n  easing;\n  onUpdate;\n  /**\n   * Advance the animation by the given delta time\n   *\n   * @param deltaTime - The time in seconds to advance the animation\n   */\n  advance(deltaTime) {\n    if (!this.isRunning) return;\n    let completed = false;\n    if (this.duration && this.easing) {\n      this.currentTime += deltaTime;\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1);\n      completed = linearProgress >= 1;\n      const easedProgress = completed ? 1 : this.easing(linearProgress);\n      this.value = this.from + (this.to - this.from) * easedProgress;\n    } else if (this.lerp) {\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime);\n      if (Math.round(this.value) === this.to) {\n        this.value = this.to;\n        completed = true;\n      }\n    } else {\n      this.value = this.to;\n      completed = true;\n    }\n    if (completed) {\n      this.stop();\n    }\n    this.onUpdate?.(this.value, completed);\n  }\n  /** Stop the animation */\n  stop() {\n    this.isRunning = false;\n  }\n  /**\n   * Set up the animation from a starting value to an ending value\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\n   *\n   * @param from - The starting value\n   * @param to - The ending value\n   * @param options - Options for the animation\n   */\n  fromTo(from, to, {\n    lerp: lerp2,\n    duration,\n    easing,\n    onStart,\n    onUpdate\n  }) {\n    this.from = this.value = from;\n    this.to = to;\n    this.lerp = lerp2;\n    this.duration = duration;\n    this.easing = easing;\n    this.currentTime = 0;\n    this.isRunning = true;\n    onStart?.();\n    this.onUpdate = onUpdate;\n  }\n};\n\n// packages/core/src/debounce.ts\nfunction debounce(callback, delay) {\n  let timer;\n  return function (...args) {\n    let context = this;\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      timer = void 0;\n      callback.apply(context, args);\n    }, delay);\n  };\n}\n\n// packages/core/src/dimensions.ts\nvar Dimensions = class {\n  constructor(wrapper, content, {\n    autoResize = true,\n    debounce: debounceValue = 250\n  } = {}) {\n    this.wrapper = wrapper;\n    this.content = content;\n    if (autoResize) {\n      this.debouncedResize = debounce(this.resize, debounceValue);\n      if (this.wrapper instanceof Window) {\n        window.addEventListener(\"resize\", this.debouncedResize, false);\n      } else {\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize);\n        this.wrapperResizeObserver.observe(this.wrapper);\n      }\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize);\n      this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  width = 0;\n  height = 0;\n  scrollHeight = 0;\n  scrollWidth = 0;\n  // These are instanciated in the constructor as they need information from the options\n  debouncedResize;\n  wrapperResizeObserver;\n  contentResizeObserver;\n  destroy() {\n    this.wrapperResizeObserver?.disconnect();\n    this.contentResizeObserver?.disconnect();\n    if (this.wrapper === window && this.debouncedResize) {\n      window.removeEventListener(\"resize\", this.debouncedResize, false);\n    }\n  }\n  resize = () => {\n    this.onWrapperResize();\n    this.onContentResize();\n  };\n  onWrapperResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.width = window.innerWidth;\n      this.height = window.innerHeight;\n    } else {\n      this.width = this.wrapper.clientWidth;\n      this.height = this.wrapper.clientHeight;\n    }\n  };\n  onContentResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.scrollHeight = this.content.scrollHeight;\n      this.scrollWidth = this.content.scrollWidth;\n    } else {\n      this.scrollHeight = this.wrapper.scrollHeight;\n      this.scrollWidth = this.wrapper.scrollWidth;\n    }\n  };\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n};\n\n// packages/core/src/emitter.ts\nvar Emitter = class {\n  events = {};\n  /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */\n  emit(event, ...args) {\n    let callbacks = this.events[event] || [];\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i]?.(...args);\n    }\n  }\n  /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */\n  on(event, cb) {\n    this.events[event]?.push(cb) || (this.events[event] = [cb]);\n    return () => {\n      this.events[event] = this.events[event]?.filter(i => cb !== i);\n    };\n  }\n  /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event, callback) {\n    this.events[event] = this.events[event]?.filter(i => callback !== i);\n  }\n  /**\n   * Remove all event listeners and clean up\n   */\n  destroy() {\n    this.events = {};\n  }\n};\n\n// packages/core/src/virtual-scroll.ts\nvar LINE_HEIGHT = 100 / 6;\nvar listenerOptions = {\n  passive: false\n};\nvar VirtualScroll = class {\n  constructor(element, options = {\n    wheelMultiplier: 1,\n    touchMultiplier: 1\n  }) {\n    this.element = element;\n    this.options = options;\n    window.addEventListener(\"resize\", this.onWindowResize, false);\n    this.onWindowResize();\n    this.element.addEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.addEventListener(\"touchstart\", this.onTouchStart, listenerOptions);\n    this.element.addEventListener(\"touchmove\", this.onTouchMove, listenerOptions);\n    this.element.addEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n  }\n  touchStart = {\n    x: 0,\n    y: 0\n  };\n  lastDelta = {\n    x: 0,\n    y: 0\n  };\n  window = {\n    width: 0,\n    height: 0\n  };\n  emitter = new Emitter();\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  /** Remove all event listeners and clean up */\n  destroy() {\n    this.emitter.destroy();\n    window.removeEventListener(\"resize\", this.onWindowResize, false);\n    this.element.removeEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.removeEventListener(\"touchstart\", this.onTouchStart, listenerOptions);\n    this.element.removeEventListener(\"touchmove\", this.onTouchMove, listenerOptions);\n    this.element.removeEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n  }\n  /**\n   * Event handler for 'touchstart' event\n   *\n   * @param event Touch event\n   */\n  onTouchStart = event => {\n    const {\n      clientX,\n      clientY\n    } = event.targetTouches ? event.targetTouches[0] : event;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: 0,\n      y: 0\n    };\n    this.emitter.emit(\"scroll\", {\n      deltaX: 0,\n      deltaY: 0,\n      event\n    });\n  };\n  /** Event handler for 'touchmove' event */\n  onTouchMove = event => {\n    const {\n      clientX,\n      clientY\n    } = event.targetTouches ? event.targetTouches[0] : event;\n    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier;\n    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: deltaX,\n      y: deltaY\n    };\n    this.emitter.emit(\"scroll\", {\n      deltaX,\n      deltaY,\n      event\n    });\n  };\n  onTouchEnd = event => {\n    this.emitter.emit(\"scroll\", {\n      deltaX: this.lastDelta.x,\n      deltaY: this.lastDelta.y,\n      event\n    });\n  };\n  /** Event handler for 'wheel' event */\n  onWheel = event => {\n    let {\n      deltaX,\n      deltaY,\n      deltaMode\n    } = event;\n    const multiplierX = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1;\n    const multiplierY = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1;\n    deltaX *= multiplierX;\n    deltaY *= multiplierY;\n    deltaX *= this.options.wheelMultiplier;\n    deltaY *= this.options.wheelMultiplier;\n    this.emitter.emit(\"scroll\", {\n      deltaX,\n      deltaY,\n      event\n    });\n  };\n  onWindowResize = () => {\n    this.window = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n  };\n};\n\n// packages/core/src/lenis.ts\nvar Lenis = class {\n  _isScrolling = false;\n  // true when scroll is animating\n  _isStopped = false;\n  // true if user should not be able to scroll - enable/disable programmatically\n  _isLocked = false;\n  // same as isStopped but enabled/disabled when scroll reaches target\n  _preventNextNativeScrollEvent = false;\n  _resetVelocityTimeout = null;\n  __rafID = null;\n  /**\n   * Whether or not the user is touching the screen\n   */\n  isTouching;\n  /**\n   * The time in ms since the lenis instance was created\n   */\n  time = 0;\n  /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */\n  userData = {};\n  /**\n   * The last velocity of the scroll\n   */\n  lastVelocity = 0;\n  /**\n   * The current velocity of the scroll\n   */\n  velocity = 0;\n  /**\n   * The direction of the scroll\n   */\n  direction = 0;\n  /**\n   * The options passed to the lenis instance\n   */\n  options;\n  /**\n   * The target scroll value\n   */\n  targetScroll;\n  /**\n   * The animated scroll value\n   */\n  animatedScroll;\n  // These are instanciated here as they don't need information from the options\n  animate = new Animate();\n  emitter = new Emitter();\n  // These are instanciated in the constructor as they need information from the options\n  dimensions;\n  // This is not private because it's used in the Snap class\n  virtualScroll;\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaMultiplier = 35,\n    duration,\n    // in seconds\n    easing = t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n    lerp: lerp2 = 0.1,\n    infinite = false,\n    orientation = \"vertical\",\n    // vertical, horizontal\n    gestureOrientation = \"vertical\",\n    // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    autoRaf = false,\n    anchors = false,\n    __experimental__naiveDimensions = false\n  } = {}) {\n    window.lenisVersion = version;\n    if (!wrapper || wrapper === document.documentElement) {\n      wrapper = window;\n    }\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaMultiplier,\n      duration,\n      easing,\n      lerp: lerp2,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      autoRaf,\n      anchors,\n      __experimental__naiveDimensions\n    };\n    this.dimensions = new Dimensions(wrapper, content, {\n      autoResize\n    });\n    this.updateClassName();\n    this.targetScroll = this.animatedScroll = this.actualScroll;\n    this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, false);\n    this.options.wrapper.addEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.addEventListener(\"click\", this.onClick, false);\n    }\n    this.options.wrapper.addEventListener(\"pointerdown\", this.onPointerDown, false);\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\n      touchMultiplier,\n      wheelMultiplier\n    });\n    this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf);\n    }\n  }\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy();\n    this.options.wrapper.removeEventListener(\"scroll\", this.onNativeScroll, false);\n    this.options.wrapper.removeEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    this.options.wrapper.removeEventListener(\"pointerdown\", this.onPointerDown, false);\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.removeEventListener(\"click\", this.onClick, false);\n    }\n    this.virtualScroll.destroy();\n    this.dimensions.destroy();\n    this.cleanUpClassName();\n    if (this.__rafID) {\n      cancelAnimationFrame(this.__rafID);\n    }\n  }\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  off(event, callback) {\n    return this.emitter.off(event, callback);\n  }\n  onScrollEnd = e => {\n    if (!(e instanceof CustomEvent)) {\n      if (this.isScrolling === \"smooth\" || this.isScrolling === false) {\n        e.stopPropagation();\n      }\n    }\n  };\n  dispatchScrollendEvent = () => {\n    this.options.wrapper.dispatchEvent(new CustomEvent(\"scrollend\", {\n      bubbles: this.options.wrapper === window,\n      // cancelable: false,\n      detail: {\n        lenisScrollEnd: true\n      }\n    }));\n  };\n  setScroll(scroll) {\n    if (this.isHorizontal) {\n      this.options.wrapper.scrollTo({\n        left: scroll,\n        behavior: \"instant\"\n      });\n    } else {\n      this.options.wrapper.scrollTo({\n        top: scroll,\n        behavior: \"instant\"\n      });\n    }\n  }\n  onClick = event => {\n    const path = event.composedPath();\n    const anchor = path.find(node => node instanceof HTMLAnchorElement && node.getAttribute(\"href\")?.startsWith(\"#\"));\n    if (anchor) {\n      const id = anchor.getAttribute(\"href\");\n      if (id) {\n        const options = typeof this.options.anchors === \"object\" && this.options.anchors ? this.options.anchors : void 0;\n        this.scrollTo(id, options);\n      }\n    }\n  };\n  onPointerDown = event => {\n    if (event.button === 1) {\n      this.reset();\n    }\n  };\n  onVirtualScroll = data => {\n    if (typeof this.options.virtualScroll === \"function\" && this.options.virtualScroll(data) === false) return;\n    const {\n      deltaX,\n      deltaY,\n      event\n    } = data;\n    this.emitter.emit(\"virtual-scroll\", {\n      deltaX,\n      deltaY,\n      event\n    });\n    if (event.ctrlKey) return;\n    if (event.lenisStopPropagation) return;\n    const isTouch = event.type.includes(\"touch\");\n    const isWheel = event.type.includes(\"wheel\");\n    this.isTouching = event.type === \"touchstart\" || event.type === \"touchmove\";\n    const isClickOrTap = deltaX === 0 && deltaY === 0;\n    const isTapToStop = this.options.syncTouch && isTouch && event.type === \"touchstart\" && isClickOrTap && !this.isStopped && !this.isLocked;\n    if (isTapToStop) {\n      this.reset();\n      return;\n    }\n    const isUnknownGesture = this.options.gestureOrientation === \"vertical\" && deltaY === 0 || this.options.gestureOrientation === \"horizontal\" && deltaX === 0;\n    if (isClickOrTap || isUnknownGesture) {\n      return;\n    }\n    let composedPath = event.composedPath();\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement));\n    const prevent = this.options.prevent;\n    if (!!composedPath.find(node => node instanceof HTMLElement && (typeof prevent === \"function\" && prevent?.(node) || node.hasAttribute?.(\"data-lenis-prevent\") || isTouch && node.hasAttribute?.(\"data-lenis-prevent-touch\") || isWheel && node.hasAttribute?.(\"data-lenis-prevent-wheel\")))) return;\n    if (this.isStopped || this.isLocked) {\n      event.preventDefault();\n      return;\n    }\n    const isSmooth = this.options.syncTouch && isTouch || this.options.smoothWheel && isWheel;\n    if (!isSmooth) {\n      this.isScrolling = \"native\";\n      this.animate.stop();\n      event.lenisStopPropagation = true;\n      return;\n    }\n    let delta = deltaY;\n    if (this.options.gestureOrientation === \"both\") {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;\n    } else if (this.options.gestureOrientation === \"horizontal\") {\n      delta = deltaX;\n    }\n    if (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && deltaY > 0 || this.animatedScroll === this.limit && deltaY < 0)) {\n      event.lenisStopPropagation = true;\n    }\n    event.preventDefault();\n    const isSyncTouch = isTouch && this.options.syncTouch;\n    const isTouchEnd = isTouch && event.type === \"touchend\";\n    const hasTouchInertia = isTouchEnd && Math.abs(delta) > 5;\n    if (hasTouchInertia) {\n      delta = this.velocity * this.options.touchInertiaMultiplier;\n    }\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...(isSyncTouch ? {\n        lerp: hasTouchInertia ? this.options.syncTouchLerp : 1\n        // immediate: !hasTouchInertia,\n      } : {\n        lerp: this.options.lerp,\n        duration: this.options.duration,\n        easing: this.options.easing\n      })\n    });\n  };\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize();\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.emit();\n  }\n  emit() {\n    this.emitter.emit(\"scroll\", this);\n  }\n  onNativeScroll = () => {\n    if (this._resetVelocityTimeout !== null) {\n      clearTimeout(this._resetVelocityTimeout);\n      this._resetVelocityTimeout = null;\n    }\n    if (this._preventNextNativeScrollEvent) {\n      this._preventNextNativeScrollEvent = false;\n      return;\n    }\n    if (this.isScrolling === false || this.isScrolling === \"native\") {\n      const lastScroll = this.animatedScroll;\n      this.animatedScroll = this.targetScroll = this.actualScroll;\n      this.lastVelocity = this.velocity;\n      this.velocity = this.animatedScroll - lastScroll;\n      this.direction = Math.sign(this.animatedScroll - lastScroll);\n      if (!this.isStopped) {\n        this.isScrolling = \"native\";\n      }\n      this.emit();\n      if (this.velocity !== 0) {\n        this._resetVelocityTimeout = setTimeout(() => {\n          this.lastVelocity = this.velocity;\n          this.velocity = 0;\n          this.isScrolling = false;\n          this.emit();\n        }, 400);\n      }\n    }\n  };\n  reset() {\n    this.isLocked = false;\n    this.isScrolling = false;\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.lastVelocity = this.velocity = 0;\n    this.animate.stop();\n  }\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return;\n    this.reset();\n    this.isStopped = false;\n  }\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return;\n    this.reset();\n    this.isStopped = true;\n  }\n  /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */\n  raf = time => {\n    const deltaTime = time - (this.time || time);\n    this.time = time;\n    this.animate.advance(deltaTime * 1e-3);\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf);\n    }\n  };\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */\n  scrollTo(target, {\n    offset = 0,\n    immediate = false,\n    lock = false,\n    duration = this.options.duration,\n    easing = this.options.easing,\n    lerp: lerp2 = this.options.lerp,\n    onStart,\n    onComplete,\n    force = false,\n    // scroll even if stopped\n    programmatic = true,\n    // called from outside of the class\n    userData\n  } = {}) {\n    if ((this.isStopped || this.isLocked) && !force) return;\n    if (typeof target === \"string\" && [\"top\", \"left\", \"start\"].includes(target)) {\n      target = 0;\n    } else if (typeof target === \"string\" && [\"bottom\", \"right\", \"end\"].includes(target)) {\n      target = this.limit;\n    } else {\n      let node;\n      if (typeof target === \"string\") {\n        node = document.querySelector(target);\n      } else if (target instanceof HTMLElement && target?.nodeType) {\n        node = target;\n      }\n      if (node) {\n        if (this.options.wrapper !== window) {\n          const wrapperRect = this.rootElement.getBoundingClientRect();\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;\n        }\n        const rect = node.getBoundingClientRect();\n        target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;\n      }\n    }\n    if (typeof target !== \"number\") return;\n    target += offset;\n    target = Math.round(target);\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll;\n      }\n    } else {\n      target = clamp(0, target, this.limit);\n    }\n    if (target === this.targetScroll) {\n      onStart?.(this);\n      onComplete?.(this);\n      return;\n    }\n    this.userData = userData ?? {};\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target;\n      this.setScroll(this.scroll);\n      this.reset();\n      this.preventNextNativeScrollEvent();\n      this.emit();\n      onComplete?.(this);\n      this.userData = {};\n      requestAnimationFrame(() => {\n        this.dispatchScrollendEvent();\n      });\n      return;\n    }\n    if (!programmatic) {\n      this.targetScroll = target;\n    }\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp: lerp2,\n      onStart: () => {\n        if (lock) this.isLocked = true;\n        this.isScrolling = \"smooth\";\n        onStart?.(this);\n      },\n      onUpdate: (value, completed) => {\n        this.isScrolling = \"smooth\";\n        this.lastVelocity = this.velocity;\n        this.velocity = value - this.animatedScroll;\n        this.direction = Math.sign(this.velocity);\n        this.animatedScroll = value;\n        this.setScroll(this.scroll);\n        if (programmatic) {\n          this.targetScroll = value;\n        }\n        if (!completed) this.emit();\n        if (completed) {\n          this.reset();\n          this.emit();\n          onComplete?.(this);\n          this.userData = {};\n          requestAnimationFrame(() => {\n            this.dispatchScrollendEvent();\n          });\n          this.preventNextNativeScrollEvent();\n        }\n      }\n    });\n  }\n  preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true;\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false;\n    });\n  }\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n  }\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.__experimental__naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth;\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight;\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n    }\n  }\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === \"horizontal\";\n  }\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    const wrapper = this.options.wrapper;\n    return this.isHorizontal ? wrapper.scrollX ?? wrapper.scrollLeft : wrapper.scrollY ?? wrapper.scrollTop;\n  }\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll;\n  }\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    return this.limit === 0 ? 1 : this.scroll / this.limit;\n  }\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling;\n  }\n  set isScrolling(value) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped;\n  }\n  set isStopped(value) {\n    if (this._isStopped !== value) {\n      this._isStopped = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked;\n  }\n  set isLocked(value) {\n    if (this._isLocked !== value) {\n      this._isLocked = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === \"smooth\";\n  }\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = \"lenis\";\n    if (this.isStopped) className += \" lenis-stopped\";\n    if (this.isLocked) className += \" lenis-locked\";\n    if (this.isScrolling) className += \" lenis-scrolling\";\n    if (this.isScrolling === \"smooth\") className += \" lenis-smooth\";\n    return className;\n  }\n  updateClassName() {\n    this.cleanUpClassName();\n    this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();\n  }\n  cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className.replace(/lenis(-\\w+)?/g, \"\").trim();\n  }\n};\nexport { Lenis as default };","map":{"version":3,"names":["version","clamp","min","input","max","Math","lerp","x","y","t","damp","lambda","deltaTime","exp","modulo","n","d","Animate","isRunning","value","from","to","currentTime","duration","easing","onUpdate","advance","completed","linearProgress","easedProgress","round","stop","fromTo","lerp2","onStart","debounce","callback","delay","timer","args","context","clearTimeout","setTimeout","apply","Dimensions","constructor","wrapper","content","autoResize","debounceValue","debouncedResize","resize","Window","window","addEventListener","wrapperResizeObserver","ResizeObserver","observe","contentResizeObserver","width","height","scrollHeight","scrollWidth","destroy","disconnect","removeEventListener","onWrapperResize","onContentResize","innerWidth","innerHeight","clientWidth","clientHeight","limit","Emitter","events","emit","event","callbacks","i","length","on","cb","push","filter","off","LINE_HEIGHT","listenerOptions","passive","VirtualScroll","element","options","wheelMultiplier","touchMultiplier","onWindowResize","onWheel","onTouchStart","onTouchMove","onTouchEnd","touchStart","lastDelta","emitter","clientX","clientY","targetTouches","deltaX","deltaY","deltaMode","multiplierX","multiplierY","Lenis","_isScrolling","_isStopped","_isLocked","_preventNextNativeScrollEvent","_resetVelocityTimeout","__rafID","isTouching","time","userData","lastVelocity","velocity","direction","targetScroll","animatedScroll","animate","dimensions","virtualScroll","document","documentElement","eventsTarget","smoothWheel","syncTouch","syncTouchLerp","touchInertiaMultiplier","pow","infinite","orientation","gestureOrientation","prevent","overscroll","autoRaf","anchors","__experimental__naiveDimensions","lenisVersion","updateClassName","actualScroll","onNativeScroll","onScrollEnd","capture","onClick","onPointerDown","onVirtualScroll","requestAnimationFrame","raf","cleanUpClassName","cancelAnimationFrame","e","CustomEvent","isScrolling","stopPropagation","dispatchScrollendEvent","dispatchEvent","bubbles","detail","lenisScrollEnd","setScroll","scroll","isHorizontal","scrollTo","left","behavior","top","path","composedPath","anchor","find","node","HTMLAnchorElement","getAttribute","startsWith","id","button","reset","data","ctrlKey","lenisStopPropagation","isTouch","type","includes","isWheel","isClickOrTap","isTapToStop","isStopped","isLocked","isUnknownGesture","slice","indexOf","rootElement","HTMLElement","hasAttribute","preventDefault","isSmooth","delta","abs","isSyncTouch","isTouchEnd","hasTouchInertia","programmatic","lastScroll","sign","start","target","offset","immediate","lock","onComplete","force","querySelector","nodeType","wrapperRect","getBoundingClientRect","rect","preventNextNativeScrollEvent","scrollX","scrollLeft","scrollY","scrollTop","progress","className","trim","replace"],"sources":["/Users/roberto/Desktop/main-template/brilio-template-v1.0/node_modules/lenis/package.json","/Users/roberto/Desktop/main-template/brilio-template-v1.0/node_modules/lenis/packages/core/src/maths.ts","/Users/roberto/Desktop/main-template/brilio-template-v1.0/node_modules/lenis/packages/core/src/animate.ts","/Users/roberto/Desktop/main-template/brilio-template-v1.0/node_modules/lenis/packages/core/src/debounce.ts","/Users/roberto/Desktop/main-template/brilio-template-v1.0/node_modules/lenis/packages/core/src/dimensions.ts","/Users/roberto/Desktop/main-template/brilio-template-v1.0/node_modules/lenis/packages/core/src/emitter.ts","/Users/roberto/Desktop/main-template/brilio-template-v1.0/node_modules/lenis/packages/core/src/virtual-scroll.ts","/Users/roberto/Desktop/main-template/brilio-template-v1.0/node_modules/lenis/packages/core/src/lenis.ts"],"sourcesContent":["{\n  \"name\": \"lenis\",\n  \"version\": \"1.1.21\",\n  \"description\": \"How smooth scroll should be\",\n  \"type\": \"module\",\n  \"sideEffects\": false,\n  \"author\": \"darkroom.engineering\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/darkroomengineering/lenis.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/darkroomengineering/lenis/issues\"\n  },\n  \"homepage\": \"https://github.com/darkroomengineering/lenis\",\n  \"funding\": {\n    \"type\": \"github\",\n    \"url\": \"https://github.com/sponsors/darkroomengineering\"\n  },\n  \"keywords\": [\n    \"scroll\",\n    \"smooth\",\n    \"lenis\",\n    \"react\",\n    \"vue\"\n  ],\n  \"scripts\": {\n    \"build\": \"pnpm build:core && pnpm build:all\",\n    \"build:core\": \"tsup --config tsup.core.ts\",\n    \"build:all\": \"tsup\",\n    \"dev\": \"pnpm run -w --parallel /^dev:.*/\",\n    \"dev:build\": \"tsup --watch\",\n    \"dev:playground\": \"pnpm --filter playground dev\",\n    \"dev:nuxt\": \"pnpm --filter playground-nuxt dev\",\n    \"readme\": \"node ./scripts/update-readme.js\",\n    \"version:dev\": \"npm version prerelease --preid dev --force --no-git-tag-version\",\n    \"version:patch\": \"npm version patch --force --no-git-tag-version\",\n    \"version:minor\": \"npm version minor --force --no-git-tag-version\",\n    \"version:major\": \"npm version major --force --no-git-tag-version\",\n    \"postversion\": \"pnpm build && pnpm readme\",\n    \"publish:main\": \"npm publish\",\n    \"publish:dev\": \"npm publish --tag dev\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"devDependencies\": {\n    \"terser\": \"^5.37.0\",\n    \"tsup\": \"^8.3.5\",\n    \"typescript\": \"^5.7.3\"\n  },\n  \"peerDependencies\": {\n    \"react\": \">=17.0.0\",\n    \"vue\": \">=3.0.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"react\": {\n      \"optional\": true\n    },\n    \"vue\": {\n      \"optional\": true\n    }\n  },\n  \"unpkg\": \"./dist/lenis.mjs\",\n  \"main\": \"./dist/lenis.mjs\",\n  \"module\": \"./dist/lenis.mjs\",\n  \"types\": \"./dist/lenis.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/lenis.d.ts\",\n      \"default\": \"./dist/lenis.mjs\"\n    },\n    \"./react\": {\n      \"types\": \"./dist/lenis-react.d.ts\",\n      \"default\": \"./dist/lenis-react.mjs\"\n    },\n    \"./snap\": {\n      \"types\": \"./dist/lenis-snap.d.ts\",\n      \"default\": \"./dist/lenis-snap.mjs\"\n    },\n    \"./vue\": {\n      \"types\": \"./dist/lenis-vue.d.ts\",\n      \"default\": \"./dist/lenis-vue.mjs\"\n    },\n    \"./nuxt\": {\n      \"default\": \"./dist/lenis-vue-nuxt.mjs\"\n    },\n    \"./dist/*\": \"./dist/*\"\n  }\n}\n","/**\n * Clamp a value between a minimum and maximum value\n *\n * @param min Minimum value\n * @param input Value to clamp\n * @param max Maximum value\n * @returns Clamped value\n */\nexport function clamp(min: number, input: number, max: number) {\n  return Math.max(min, Math.min(input, max))\n}\n\n/**\n * Truncate a floating-point number to a specified number of decimal places\n *\n * @param value Value to truncate\n * @param decimals Number of decimal places to truncate to\n * @returns Truncated value\n */\nexport function truncate(value: number, decimals = 0) {\n  return parseFloat(value.toFixed(decimals))\n}\n\n/**\n *  Linearly interpolate between two values using an amount (0 <= t <= 1)\n *\n * @param x First value\n * @param y Second value\n * @param t Amount to interpolate (0 <= t <= 1)\n * @returns Interpolated value\n */\nexport function lerp(x: number, y: number, t: number) {\n  return (1 - t) * x + t * y\n}\n\n/**\n * Damp a value over time using a damping factor\n * {@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}\n *\n * @param x Initial value\n * @param y Target value\n * @param lambda Damping factor\n * @param dt Time elapsed since the last update\n * @returns Damped value\n */\nexport function damp(x: number, y: number, lambda: number, deltaTime: number) {\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime))\n}\n\n/**\n * Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\n * {@link https://anguscroll.com/just/just-modulo}\n *\n * @param n Dividend\n * @param d Divisor\n * @returns Modulo\n */\nexport function modulo(n: number, d: number) {\n  return ((n % d) + d) % d\n}\n","import { clamp, damp } from './maths'\nimport type { EasingFunction, FromToOptions, OnUpdateCallback } from './types'\n\n/**\n * Animate class to handle value animations with lerping or easing\n *\n * @example\n * const animate = new Animate()\n * animate.fromTo(0, 100, { duration: 1, easing: (t) => t })\n * animate.advance(0.5) // 50\n */\nexport class Animate {\n  isRunning = false\n  value = 0\n  from = 0\n  to = 0\n  currentTime = 0\n\n  // These are instanciated in the fromTo method\n  lerp?: number\n  duration?: number\n  easing?: EasingFunction\n  onUpdate?: OnUpdateCallback\n\n  /**\n   * Advance the animation by the given delta time\n   *\n   * @param deltaTime - The time in seconds to advance the animation\n   */\n  advance(deltaTime: number) {\n    if (!this.isRunning) return\n\n    let completed = false\n\n    if (this.duration && this.easing) {\n      this.currentTime += deltaTime\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\n\n      completed = linearProgress >= 1\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\n      this.value = this.from + (this.to - this.from) * easedProgress\n    } else if (this.lerp) {\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\n      if (Math.round(this.value) === this.to) {\n        this.value = this.to\n        completed = true\n      }\n    } else {\n      // If no easing or lerp, just jump to the end value\n      this.value = this.to\n      completed = true\n    }\n\n    if (completed) {\n      this.stop()\n    }\n\n    // Call the onUpdate callback with the current value and completed status\n    this.onUpdate?.(this.value, completed)\n  }\n\n  /** Stop the animation */\n  stop() {\n    this.isRunning = false\n  }\n\n  /**\n   * Set up the animation from a starting value to an ending value\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\n   *\n   * @param from - The starting value\n   * @param to - The ending value\n   * @param options - Options for the animation\n   */\n  fromTo(\n    from: number,\n    to: number,\n    { lerp, duration, easing, onStart, onUpdate }: FromToOptions\n  ) {\n    this.from = this.value = from\n    this.to = to\n    this.lerp = lerp\n    this.duration = duration\n    this.easing = easing\n    this.currentTime = 0\n    this.isRunning = true\n\n    onStart?.()\n    this.onUpdate = onUpdate\n  }\n}\n","export function debounce<CB extends (...args: any[]) => void>(\n  callback: CB,\n  delay: number\n) {\n  let timer: number | undefined\n  return function <T>(this: T, ...args: Parameters<typeof callback>) {\n    let context = this\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      timer = undefined\n      callback.apply(context, args)\n    }, delay)\n  }\n}\n","import { debounce } from './debounce'\n\n/**\n * Dimensions class to handle the size of the content and wrapper\n *\n * @example\n * const dimensions = new Dimensions(wrapper, content)\n * dimensions.on('resize', (e) => {\n *   console.log(e.width, e.height)\n * })\n */\nexport class Dimensions {\n  width = 0\n  height = 0\n  scrollHeight = 0\n  scrollWidth = 0\n\n  // These are instanciated in the constructor as they need information from the options\n  private debouncedResize?: (...args: unknown[]) => void\n  private wrapperResizeObserver?: ResizeObserver\n  private contentResizeObserver?: ResizeObserver\n\n  constructor(\n    private wrapper: HTMLElement | Window | Element,\n    private content: HTMLElement | Element,\n    { autoResize = true, debounce: debounceValue = 250 } = {}\n  ) {\n    if (autoResize) {\n      this.debouncedResize = debounce(this.resize, debounceValue)\n\n      if (this.wrapper instanceof Window) {\n        window.addEventListener('resize', this.debouncedResize, false)\n      } else {\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize)\n        this.wrapperResizeObserver.observe(this.wrapper)\n      }\n\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize)\n      this.contentResizeObserver.observe(this.content)\n    }\n\n    this.resize()\n  }\n\n  destroy() {\n    this.wrapperResizeObserver?.disconnect()\n    this.contentResizeObserver?.disconnect()\n\n    if (this.wrapper === window && this.debouncedResize) {\n      window.removeEventListener('resize', this.debouncedResize, false)\n    }\n  }\n\n  resize = () => {\n    this.onWrapperResize()\n    this.onContentResize()\n  }\n\n  onWrapperResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.width = window.innerWidth\n      this.height = window.innerHeight\n    } else {\n      this.width = this.wrapper.clientWidth\n      this.height = this.wrapper.clientHeight\n    }\n  }\n\n  onContentResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.scrollHeight = this.content.scrollHeight\n      this.scrollWidth = this.content.scrollWidth\n    } else {\n      this.scrollHeight = this.wrapper.scrollHeight\n      this.scrollWidth = this.wrapper.scrollWidth\n    }\n  }\n\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height,\n    }\n  }\n}\n","/**\n * Emitter class to handle events\n * @example\n * const emitter = new Emitter()\n * emitter.on('event', (data) => {\n *   console.log(data)\n * })\n * emitter.emit('event', 'data')\n */\nexport class Emitter {\n  private events: Record<\n    string,\n    Array<(...args: unknown[]) => void> | undefined\n  > = {}\n\n  /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */\n  emit(event: string, ...args: unknown[]) {\n    let callbacks = this.events[event] || []\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i]?.(...args)\n    }\n  }\n\n  /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */\n  on<CB extends (...args: any[]) => void>(event: string, cb: CB) {\n    // Add the callback to the event's callback list, or create a new list with the callback\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\n\n    // Return an unsubscribe function\n    return () => {\n      this.events[event] = this.events[event]?.filter((i) => cb !== i)\n    }\n  }\n\n  /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off<CB extends (...args: any[]) => void>(event: string, callback: CB) {\n    this.events[event] = this.events[event]?.filter((i) => callback !== i)\n  }\n\n  /**\n   * Remove all event listeners and clean up\n   */\n  destroy() {\n    this.events = {}\n  }\n}\n","import { Emitter } from './emitter'\nimport type { VirtualScrollCallback } from './types'\n\nconst LINE_HEIGHT = 100 / 6\nconst listenerOptions: AddEventListenerOptions = { passive: false }\n\nexport class VirtualScroll {\n  touchStart = {\n    x: 0,\n    y: 0,\n  }\n  lastDelta = {\n    x: 0,\n    y: 0,\n  }\n  window = {\n    width: 0,\n    height: 0,\n  }\n  private emitter = new Emitter()\n\n  constructor(\n    private element: HTMLElement,\n    private options = { wheelMultiplier: 1, touchMultiplier: 1 }\n  ) {\n    window.addEventListener('resize', this.onWindowResize, false)\n    this.onWindowResize()\n\n    this.element.addEventListener('wheel', this.onWheel, listenerOptions)\n    this.element.addEventListener(\n      'touchstart',\n      this.onTouchStart,\n      listenerOptions\n    )\n    this.element.addEventListener(\n      'touchmove',\n      this.onTouchMove,\n      listenerOptions\n    )\n    this.element.addEventListener('touchend', this.onTouchEnd, listenerOptions)\n  }\n\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  on(event: string, callback: VirtualScrollCallback) {\n    return this.emitter.on(event, callback)\n  }\n\n  /** Remove all event listeners and clean up */\n  destroy() {\n    this.emitter.destroy()\n\n    window.removeEventListener('resize', this.onWindowResize, false)\n\n    this.element.removeEventListener('wheel', this.onWheel, listenerOptions)\n    this.element.removeEventListener(\n      'touchstart',\n      this.onTouchStart,\n      listenerOptions\n    )\n    this.element.removeEventListener(\n      'touchmove',\n      this.onTouchMove,\n      listenerOptions\n    )\n    this.element.removeEventListener(\n      'touchend',\n      this.onTouchEnd,\n      listenerOptions\n    )\n  }\n\n  /**\n   * Event handler for 'touchstart' event\n   *\n   * @param event Touch event\n   */\n  onTouchStart = (event: TouchEvent) => {\n    // @ts-expect-error - event.targetTouches is not defined\n    const { clientX, clientY } = event.targetTouches\n      ? event.targetTouches[0]\n      : event\n\n    this.touchStart.x = clientX\n    this.touchStart.y = clientY\n\n    this.lastDelta = {\n      x: 0,\n      y: 0,\n    }\n\n    this.emitter.emit('scroll', {\n      deltaX: 0,\n      deltaY: 0,\n      event,\n    })\n  }\n\n  /** Event handler for 'touchmove' event */\n  onTouchMove = (event: TouchEvent) => {\n    // @ts-expect-error - event.targetTouches is not defined\n    const { clientX, clientY } = event.targetTouches\n      ? event.targetTouches[0]\n      : event\n\n    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier\n    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier\n\n    this.touchStart.x = clientX\n    this.touchStart.y = clientY\n\n    this.lastDelta = {\n      x: deltaX,\n      y: deltaY,\n    }\n\n    this.emitter.emit('scroll', {\n      deltaX,\n      deltaY,\n      event,\n    })\n  }\n\n  onTouchEnd = (event: TouchEvent) => {\n    this.emitter.emit('scroll', {\n      deltaX: this.lastDelta.x,\n      deltaY: this.lastDelta.y,\n      event,\n    })\n  }\n\n  /** Event handler for 'wheel' event */\n  onWheel = (event: WheelEvent) => {\n    let { deltaX, deltaY, deltaMode } = event\n\n    const multiplierX =\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1\n    const multiplierY =\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1\n\n    deltaX *= multiplierX\n    deltaY *= multiplierY\n\n    deltaX *= this.options.wheelMultiplier\n    deltaY *= this.options.wheelMultiplier\n\n    this.emitter.emit('scroll', { deltaX, deltaY, event })\n  }\n\n  onWindowResize = () => {\n    this.window = {\n      width: window.innerWidth,\n      height: window.innerHeight,\n    }\n  }\n}\n","import { version } from '../../../package.json'\nimport { Animate } from './animate'\nimport { Dimensions } from './dimensions'\nimport { Emitter } from './emitter'\nimport { clamp, modulo } from './maths'\nimport type {\n  LenisEvent,\n  LenisOptions,\n  ScrollCallback,\n  Scrolling,\n  ScrollToOptions,\n  UserData,\n  VirtualScrollCallback,\n  VirtualScrollData,\n} from './types'\nimport { VirtualScroll } from './virtual-scroll'\n\n// Technical explanation\n// - listen to 'wheel' events\n// - prevent 'wheel' event to prevent scroll\n// - normalize wheel delta\n// - add delta to targetScroll\n// - animate scroll to targetScroll (smooth context)\n// - if animation is not running, listen to 'scroll' events (native context)\n\ntype OptionalPick<T, F extends keyof T> = Omit<T, F> & Partial<Pick<T, F>>\n\nexport class Lenis {\n  private _isScrolling: Scrolling = false // true when scroll is animating\n  private _isStopped = false // true if user should not be able to scroll - enable/disable programmatically\n  private _isLocked = false // same as isStopped but enabled/disabled when scroll reaches target\n  private _preventNextNativeScrollEvent = false\n  private _resetVelocityTimeout: number | null = null\n  private __rafID: number | null = null\n\n  /**\n   * Whether or not the user is touching the screen\n   */\n  isTouching?: boolean\n  /**\n   * The time in ms since the lenis instance was created\n   */\n  time = 0\n  /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */\n  userData: UserData = {}\n  /**\n   * The last velocity of the scroll\n   */\n  lastVelocity = 0\n  /**\n   * The current velocity of the scroll\n   */\n  velocity = 0\n  /**\n   * The direction of the scroll\n   */\n  direction: 1 | -1 | 0 = 0\n  /**\n   * The options passed to the lenis instance\n   */\n  options: OptionalPick<\n    Required<LenisOptions>,\n    'duration' | 'prevent' | 'virtualScroll'\n  >\n  /**\n   * The target scroll value\n   */\n  targetScroll: number\n  /**\n   * The animated scroll value\n   */\n  animatedScroll: number\n\n  // These are instanciated here as they don't need information from the options\n  private readonly animate = new Animate()\n  private readonly emitter = new Emitter()\n  // These are instanciated in the constructor as they need information from the options\n  readonly dimensions: Dimensions // This is not private because it's used in the Snap class\n  private readonly virtualScroll: VirtualScroll\n\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaMultiplier = 35,\n    duration, // in seconds\n    easing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n    lerp = 0.1,\n    infinite = false,\n    orientation = 'vertical', // vertical, horizontal\n    gestureOrientation = 'vertical', // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    autoRaf = false,\n    anchors = false,\n    __experimental__naiveDimensions = false,\n  }: LenisOptions = {}) {\n    // Set version\n    window.lenisVersion = version\n\n    // Check if wrapper is <html>, fallback to window\n    if (!wrapper || wrapper === document.documentElement) {\n      wrapper = window\n    }\n\n    // Setup options\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaMultiplier,\n      duration,\n      easing,\n      lerp,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      autoRaf,\n      anchors,\n      __experimental__naiveDimensions,\n    }\n\n    // Setup dimensions instance\n    this.dimensions = new Dimensions(wrapper, content, { autoResize })\n\n    // Setup class name\n    this.updateClassName()\n\n    // Set the initial scroll value for all scroll information\n    this.targetScroll = this.animatedScroll = this.actualScroll\n\n    // Add event listeners\n    this.options.wrapper.addEventListener('scroll', this.onNativeScroll, false)\n\n    this.options.wrapper.addEventListener('scrollend', this.onScrollEnd, {\n      capture: true,\n    })\n\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.addEventListener(\n        'click',\n        this.onClick as EventListener,\n        false\n      )\n    }\n\n    this.options.wrapper.addEventListener(\n      'pointerdown',\n      this.onPointerDown as EventListener,\n      false\n    )\n\n    // Setup virtual scroll instance\n    this.virtualScroll = new VirtualScroll(eventsTarget as HTMLElement, {\n      touchMultiplier,\n      wheelMultiplier,\n    })\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\n\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf)\n    }\n  }\n\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy()\n\n    this.options.wrapper.removeEventListener(\n      'scroll',\n      this.onNativeScroll,\n      false\n    )\n\n    this.options.wrapper.removeEventListener('scrollend', this.onScrollEnd, {\n      capture: true,\n    })\n\n    this.options.wrapper.removeEventListener(\n      'pointerdown',\n      this.onPointerDown as EventListener,\n      false\n    )\n\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.removeEventListener(\n        'click',\n        this.onClick as EventListener,\n        false\n      )\n    }\n\n    this.virtualScroll.destroy()\n    this.dimensions.destroy()\n\n    this.cleanUpClassName()\n\n    if (this.__rafID) {\n      cancelAnimationFrame(this.__rafID)\n    }\n  }\n\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   * @returns Unsubscribe function\n   */\n  on(event: 'scroll', callback: ScrollCallback): () => void\n  on(event: 'virtual-scroll', callback: VirtualScrollCallback): () => void\n  on(event: LenisEvent, callback: any) {\n    return this.emitter.on(event, callback)\n  }\n\n  /**\n   * Remove an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event: 'scroll', callback: ScrollCallback): void\n  off(event: 'virtual-scroll', callback: VirtualScrollCallback): void\n  off(event: LenisEvent, callback: any) {\n    return this.emitter.off(event, callback)\n  }\n\n  private onScrollEnd = (e: Event | CustomEvent) => {\n    if (!(e instanceof CustomEvent)) {\n      if (this.isScrolling === 'smooth' || this.isScrolling === false) {\n        e.stopPropagation()\n      }\n    }\n  }\n\n  private dispatchScrollendEvent = () => {\n    this.options.wrapper.dispatchEvent(\n      new CustomEvent('scrollend', {\n        bubbles: this.options.wrapper === window,\n        // cancelable: false,\n        detail: {\n          lenisScrollEnd: true,\n        },\n      })\n    )\n  }\n\n  private setScroll(scroll: number) {\n    // behavior: 'instant' bypasses the scroll-behavior CSS property\n\n    if (this.isHorizontal) {\n      this.options.wrapper.scrollTo({ left: scroll, behavior: 'instant' })\n    } else {\n      this.options.wrapper.scrollTo({ top: scroll, behavior: 'instant' })\n    }\n  }\n\n  private onClick = (event: PointerEvent | MouseEvent) => {\n    const path = event.composedPath()\n    const anchor = path.find(\n      (node) =>\n        node instanceof HTMLAnchorElement &&\n        node.getAttribute('href')?.startsWith('#')\n    ) as HTMLAnchorElement | undefined\n    if (anchor) {\n      const id = anchor.getAttribute('href')\n      if (id) {\n        const options =\n          typeof this.options.anchors === 'object' && this.options.anchors\n            ? this.options.anchors\n            : undefined\n        this.scrollTo(id, options)\n      }\n    }\n  }\n\n  private onPointerDown = (event: PointerEvent | MouseEvent) => {\n    if (event.button === 1) {\n      this.reset()\n    }\n  }\n\n  private onVirtualScroll = (data: VirtualScrollData) => {\n    if (\n      typeof this.options.virtualScroll === 'function' &&\n      this.options.virtualScroll(data) === false\n    )\n      return\n\n    const { deltaX, deltaY, event } = data\n\n    this.emitter.emit('virtual-scroll', { deltaX, deltaY, event })\n\n    // keep zoom feature\n    if (event.ctrlKey) return\n    // @ts-ignore\n    if (event.lenisStopPropagation) return\n\n    const isTouch = event.type.includes('touch')\n    const isWheel = event.type.includes('wheel')\n\n    this.isTouching = event.type === 'touchstart' || event.type === 'touchmove'\n    // if (event.type === 'touchend') {\n    //   console.log('touchend', this.scroll)\n    //   // this.lastVelocity = this.velocity\n    //   // this.velocity = 0\n    //   // this.isScrolling = false\n    //   this.emit({ type: 'touchend' })\n    //   // alert('touchend')\n    //   return\n    // }\n\n    const isClickOrTap = deltaX === 0 && deltaY === 0\n\n    const isTapToStop =\n      this.options.syncTouch &&\n      isTouch &&\n      event.type === 'touchstart' &&\n      isClickOrTap &&\n      !this.isStopped &&\n      !this.isLocked\n\n    if (isTapToStop) {\n      this.reset()\n      return\n    }\n\n    // const isPullToRefresh =\n    //   this.options.gestureOrientation === 'vertical' &&\n    //   this.scroll === 0 &&\n    //   !this.options.infinite &&\n    //   deltaY <= 5 // touch pull to refresh, not reliable yet\n\n    const isUnknownGesture =\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) ||\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0)\n\n    if (isClickOrTap || isUnknownGesture) {\n      // console.log('prevent')\n      return\n    }\n\n    // catch if scrolling on nested scroll elements\n    let composedPath = event.composedPath()\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement)) // remove parents elements\n\n    const prevent = this.options.prevent\n\n    if (\n      !!composedPath.find(\n        (node) =>\n          node instanceof HTMLElement &&\n          ((typeof prevent === 'function' && prevent?.(node)) ||\n            node.hasAttribute?.('data-lenis-prevent') ||\n            (isTouch && node.hasAttribute?.('data-lenis-prevent-touch')) ||\n            (isWheel && node.hasAttribute?.('data-lenis-prevent-wheel')))\n      )\n    )\n      return\n\n    if (this.isStopped || this.isLocked) {\n      event.preventDefault() // this will stop forwarding the event to the parent, this is problematic\n      return\n    }\n\n    const isSmooth =\n      (this.options.syncTouch && isTouch) ||\n      (this.options.smoothWheel && isWheel)\n\n    if (!isSmooth) {\n      this.isScrolling = 'native'\n      this.animate.stop()\n      // @ts-ignore\n      event.lenisStopPropagation = true\n      return\n    }\n\n    let delta = deltaY\n    if (this.options.gestureOrientation === 'both') {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\n    } else if (this.options.gestureOrientation === 'horizontal') {\n      delta = deltaX\n    }\n\n    if (\n      !this.options.overscroll ||\n      this.options.infinite ||\n      (this.options.wrapper !== window &&\n        ((this.animatedScroll > 0 && this.animatedScroll < this.limit) ||\n          (this.animatedScroll === 0 && deltaY > 0) ||\n          (this.animatedScroll === this.limit && deltaY < 0)))\n    ) {\n      // @ts-ignore\n      event.lenisStopPropagation = true\n      // event.stopPropagation()\n    }\n\n    event.preventDefault()\n\n    const isSyncTouch = isTouch && this.options.syncTouch\n    const isTouchEnd = isTouch && event.type === 'touchend'\n\n    const hasTouchInertia = isTouchEnd && Math.abs(delta) > 5\n\n    if (hasTouchInertia) {\n      delta = this.velocity * this.options.touchInertiaMultiplier\n    }\n\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...(isSyncTouch\n        ? {\n            lerp: hasTouchInertia ? this.options.syncTouchLerp : 1,\n            // immediate: !hasTouchInertia,\n          }\n        : {\n            lerp: this.options.lerp,\n            duration: this.options.duration,\n            easing: this.options.easing,\n          }),\n    })\n  }\n\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize()\n    this.animatedScroll = this.targetScroll = this.actualScroll\n    this.emit()\n  }\n\n  private emit() {\n    this.emitter.emit('scroll', this)\n  }\n\n  private onNativeScroll = () => {\n    if (this._resetVelocityTimeout !== null) {\n      clearTimeout(this._resetVelocityTimeout)\n      this._resetVelocityTimeout = null\n    }\n\n    if (this._preventNextNativeScrollEvent) {\n      this._preventNextNativeScrollEvent = false\n      return\n    }\n\n    if (this.isScrolling === false || this.isScrolling === 'native') {\n      const lastScroll = this.animatedScroll\n      this.animatedScroll = this.targetScroll = this.actualScroll\n      this.lastVelocity = this.velocity\n      this.velocity = this.animatedScroll - lastScroll\n      this.direction = Math.sign(\n        this.animatedScroll - lastScroll\n      ) as Lenis['direction']\n\n      if (!this.isStopped) {\n        this.isScrolling = 'native'\n      }\n\n      this.emit()\n\n      if (this.velocity !== 0) {\n        this._resetVelocityTimeout = setTimeout(() => {\n          this.lastVelocity = this.velocity\n          this.velocity = 0\n          this.isScrolling = false\n          this.emit()\n        }, 400)\n      }\n    }\n  }\n\n  private reset() {\n    this.isLocked = false\n    this.isScrolling = false\n    this.animatedScroll = this.targetScroll = this.actualScroll\n    this.lastVelocity = this.velocity = 0\n    this.animate.stop()\n  }\n\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return\n    this.reset()\n\n    this.isStopped = false\n  }\n\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return\n    this.reset()\n\n    this.isStopped = true\n  }\n\n  /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */\n  raf = (time: number) => {\n    const deltaTime = time - (this.time || time)\n    this.time = time\n\n    this.animate.advance(deltaTime * 0.001)\n\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf)\n    }\n  }\n\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */\n  scrollTo(\n    target: number | string | HTMLElement,\n    {\n      offset = 0,\n      immediate = false,\n      lock = false,\n      duration = this.options.duration,\n      easing = this.options.easing,\n      lerp = this.options.lerp,\n      onStart,\n      onComplete,\n      force = false, // scroll even if stopped\n      programmatic = true, // called from outside of the class\n      userData,\n    }: ScrollToOptions = {}\n  ) {\n    if ((this.isStopped || this.isLocked) && !force) return\n\n    // keywords\n    if (\n      typeof target === 'string' &&\n      ['top', 'left', 'start'].includes(target)\n    ) {\n      target = 0\n    } else if (\n      typeof target === 'string' &&\n      ['bottom', 'right', 'end'].includes(target)\n    ) {\n      target = this.limit\n    } else {\n      let node\n\n      if (typeof target === 'string') {\n        // CSS selector\n        node = document.querySelector(target)\n      } else if (target instanceof HTMLElement && target?.nodeType) {\n        // Node element\n        node = target\n      }\n\n      if (node) {\n        if (this.options.wrapper !== window) {\n          // nested scroll offset correction\n          const wrapperRect = this.rootElement.getBoundingClientRect()\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\n        }\n\n        const rect = node.getBoundingClientRect()\n\n        target =\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\n      }\n    }\n\n    if (typeof target !== 'number') return\n\n    target += offset\n    target = Math.round(target)\n\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll\n      }\n    } else {\n      target = clamp(0, target, this.limit)\n    }\n\n    if (target === this.targetScroll) {\n      onStart?.(this)\n      onComplete?.(this)\n      return\n    }\n\n    this.userData = userData ?? {}\n\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target\n      this.setScroll(this.scroll)\n      this.reset()\n      this.preventNextNativeScrollEvent()\n      this.emit()\n      onComplete?.(this)\n      this.userData = {}\n\n      requestAnimationFrame(() => {\n        this.dispatchScrollendEvent()\n      })\n      return\n    }\n\n    if (!programmatic) {\n      this.targetScroll = target\n    }\n\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp,\n      onStart: () => {\n        // started\n        if (lock) this.isLocked = true\n        this.isScrolling = 'smooth'\n        onStart?.(this)\n      },\n      onUpdate: (value: number, completed: boolean) => {\n        this.isScrolling = 'smooth'\n\n        // updated\n        this.lastVelocity = this.velocity\n        this.velocity = value - this.animatedScroll\n        this.direction = Math.sign(this.velocity) as Lenis['direction']\n\n        this.animatedScroll = value\n        this.setScroll(this.scroll)\n\n        if (programmatic) {\n          // wheel during programmatic should stop it\n          this.targetScroll = value\n        }\n\n        if (!completed) this.emit()\n\n        if (completed) {\n          this.reset()\n          this.emit()\n          onComplete?.(this)\n          this.userData = {}\n\n          requestAnimationFrame(() => {\n            this.dispatchScrollendEvent()\n          })\n\n          // avoid emitting event twice\n          this.preventNextNativeScrollEvent()\n        }\n      },\n    })\n  }\n\n  private preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true\n\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false\n    })\n  }\n\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return (\n      this.options.wrapper === window\n        ? document.documentElement\n        : this.options.wrapper\n    ) as HTMLElement\n  }\n\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.__experimental__naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? 'x' : 'y']\n    }\n  }\n\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === 'horizontal'\n  }\n\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    // value browser takes into account\n    // it has to be this way because of DOCTYPE declaration\n    const wrapper = this.options.wrapper as Window | HTMLElement\n\n    return this.isHorizontal\n      ? (wrapper as Window).scrollX ?? (wrapper as HTMLElement).scrollLeft\n      : (wrapper as Window).scrollY ?? (wrapper as HTMLElement).scrollTop\n  }\n\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite\n      ? modulo(this.animatedScroll, this.limit)\n      : this.animatedScroll\n  }\n\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    // avoid progress to be NaN\n    return this.limit === 0 ? 1 : this.scroll / this.limit\n  }\n\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling\n  }\n\n  private set isScrolling(value: Scrolling) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped\n  }\n\n  private set isStopped(value: boolean) {\n    if (this._isStopped !== value) {\n      this._isStopped = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked\n  }\n\n  private set isLocked(value: boolean) {\n    if (this._isLocked !== value) {\n      this._isLocked = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === 'smooth'\n  }\n\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = 'lenis'\n    if (this.isStopped) className += ' lenis-stopped'\n    if (this.isLocked) className += ' lenis-locked'\n    if (this.isScrolling) className += ' lenis-scrolling'\n    if (this.isScrolling === 'smooth') className += ' lenis-smooth'\n    return className\n  }\n\n  private updateClassName() {\n    this.cleanUpClassName()\n\n    this.rootElement.className =\n      `${this.rootElement.className} ${this.className}`.trim()\n  }\n\n  private cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className\n      .replace(/lenis(-\\w+)?/g, '')\n      .trim()\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}